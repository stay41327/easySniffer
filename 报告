嗅探器
						胡正浩	5110369037
						张宇韬	5110729059

一、环境
系统环境是Ubuntu下，需安装Python 2.7.5
程序中调用了scapy和thread库用于抓包的内部实现（具体代码在snlib.py中），界面调用了Tkinter库和Tkinter的扩展库Pmw（具体代码在User Interface.py中）

安装命令：
Apt-get install python-scapy
Apt-get install python-Tkinter
Apt-get install python-pmw

二、功能

本抓包软件实现了以下几个功能：
1）抓包及包内容解析
2）包过滤
3）关键字搜索
4）抓包日志保存
5）IP包分段重组
6) 单个TCP流文件重组

三、功能实现

（一）变量介绍

Stop_Button_Click，布尔型变量，控制抓包函数的开始与停止，默认值为False，置为True时停止抓包；
Content，字符串，保存单个TCP流重组后的文件；
pktBuf，列表，保存数据包的信息，每个数据包都以一个列表的形式保存在pktBuuf中，包括数据包的头部信息和数据内容，格式：[ [二层数据包协议名，[ 二层包头信息，[三层数据包协议名，三层包头信息，数据段] ] ]….]；
pktCont，列表，保存数据包中数据部分的内容，与pktBuf中的数据包一一对应，格式：[ 数据，….]；
Protocol，列表，保存了数据包的最高层协议名称，（暂时之实现了ARP，IPv4，ICMP，TCP，UDP的解读），与pktBuf中的数据包一一对应，格式： [ 协议名，….]；
fragBuf，列表，保存IP分段中IP包数据部的内容，其中报文分段按偏移量排序。格式： [ [ IP分组标识id，[ 偏移量，数据报文] …. ] …. ]；
tabEth， 元组，保存以太网标识与协议的对应关系。（为实现方便，只写了IP和ARP的）

（二）代码实现

基本抓包的实现是通过getPkts函数实现的，接受三个参数：filterOpt控制过滤包的形式；Handle控制包解析的方式；stop_filt控制抓包的开始与停止。三个参数都接收函数类型的变量。运行期间会通过Handle参数对应的函数将数据包逐层解析，并分别对pktBuf，pktCont，Protocol进行相应的赋值。抓包时不对Handle参数进行额外的修改，包过滤由filterOpt参数控制。对于Handle的具体实现由preHand，dispatch_LOW，和dispatch_High共同实现，逐层剥离包头。

对功能（1），先将getPkts函数封装在Sniff函数中，再将Sniff函数封装在th_sniff中，其中Sniff函数设定了一些默认参数，th_sniff创建了一个新线程运行Sniff函数。接受参数包括网卡名称（eth0，wlan0），和过滤选项。网卡选项默认为eth0。
功能（2）中，通过改变th_sniff的传入参数，分别实现了指定源目的IP的抓包src_dstIP_sniff，指定源IP目的端口的抓包src_dstPort_sniff，和指定路由协议的抓包pro_sniff（之实现了ARP，IPv4，ICMP，TCP，UDP）。传入参数分别为源目的IP，网卡选项；源IP，目的端口号和网卡选项；协议名称，网卡选项。网卡选项默认为eth0。
功能（3）由search函数完成，接受一个字符串类型参数，返回一个列表，列表中包含所有满足条件的包及包头信息。
功能（4）由savPkt函数完成，以Append方式存到log文件中。
功能（5）由pkt_assemble完成，接受IPid，输出放在fragBuf中。
功能（6）由single_file_asm完成，该函数新建了一个抓包线程，在Stop_Button_Click置为True时停止。输入源目的IP地址，源端口号，和网卡选项（默认eth0），输出以字符串形式存放在Content中。

四、界面实现

（1） 页面控件介绍

（1） 由6个Entry构成。
（2） 由一个Label和Pmw库中的combobox控件组成，Label显示“choose network”用来提醒用户操作。Combobox中用来选择network。
（3） 一个listbox（文件中命名为list1），用来显示所抓获的包的信息。
（4） 一个listbox（文件中命名为list2），用来显示所抓获的包的其它详细信息。
（5） 9个Button组成：
按键Start: 抓取经过该网关（网关在choose network可选，默认为eth0）的所有包，并显示在左边2个list上
按键 Stop: 用在Start，Filter之后，停止搜索，当其它包来时，也不再抓取
按键 Filter:抓取符合条件的所有包。左上角前2行4个entry（source address，destination ip，destination port，protocol）是用于确定搜索条件。Source address 是源地址，可以搜索到指定源地址的包；destination ip 是目的地址ip，可以搜索到任何目的地址为指定地址的包，destination port是目的地址端口，可以搜索到流经指定目的地址端口的包，protocol是协议，可以搜索到用到指定协议的包（如IP，TCP，ARP，RARP）。Entry中的内容需要手动输入。
按键 Search: 用在Stop之后，用于在已有的list中搜索出指定的字符串（String）。左上角的第3行第二列的Entry（初始为search）是用于输入字符串。当输入字符串后，再点击search，可以搜索出指定字符串。
按键CheckDaily: 打开log文档内容，并将内容输出到2个list中
按键 MessageRestruct: 用于将相同Id的包组合到一起。在已经抓取包之后，点击这个按键，在list会显示重组之后的包。
按键 saveTxt:在捕捉包之后，可以将其储存到log文件中。
按键 file reconstruct: 文件重组，用于将断开的文件组合起来。
按键 Exit:点击之后退出

（二）控件调用功能
（1）单击start，在ping百度时得到的结果将显示在list1和list2中（list2中部分字由于格式问题没有完全显现）

（2）将协议类型改为“IP”之后，单击Filter，将显示ip过滤后的结果


（3）再添加目的端口，将显示过滤端口后的结果，e.g. 输入端口80


（4）点击保存txt，则将内容保存在log文件中



（6） 点击“CheckDaily”，可以将log中的文件显示出来



（7） 点击“Search”，查找数据段的关键字



五、遇到困难
我们是用scapy库来编写主要算法的，本来以为选择了一个相对高端的库可以省去很大的麻烦，但结果却并没有我们想象中那么顺利。
主要算法中，scapy有个sniff函数可以直接抓包，用起来也确实很方便，但当我们希望能通过传递一些参数来实现我们自己的功能时，却发现它的手册相当不完善，这也导致我们在如何传参的问题上花了很多时间。而且，后来我们又发现一个问题，sniff函数是一个阻塞式的函数，一旦运行起来就会不停的跑，直到手动键盘中断（Ctrl-C，Ctrl-D）才能终止。我们为sniff新建了一个线程，解决了它的阻塞问题，但我们又发现我们没办法停止抓包。最终我们翻了scapy的源码，才找到一个“隐藏参数”stop_filter来停止抓包。
虽说，scapy的函数已经对数据包做过了一定的处理，但是处理得相当粗糙，很多时候还是得自己查数据包的格式。特别是在数据流重组中，需要判断一个数据流的开始和结束，因此要识别TCP包里的SYN，ACK标志位，但scapy里把TCP包头里6个标志位全都放在一块儿输出了一个0 ~ 64的数字，也没说是按什么顺序排的，最后只能自己把包抓下来一个个看。
还有一些实现方面的问题，如：统一接口，函数传参，统一数据的格式等等。最终，通过不断地讨论解决了。


六、心得体会
本次大作业感觉上是本学期各作业中最难完成的。就最后成果来看，并没有达到我们的最理想水平，有些会由于自己知识能力不足写得不完美，有些也因为时间不充足没有完善。不过在编程的过程中，我们对socket编程有了进一步的理解，并且又由于老师对界面有要求，我们又学习了UI界面的设计和相互之间的连接，不仅是对计算机网络这门课，对编程能力和软件工程的相关内容学习也更进一步。从选择语言来讲，由于软件对代码执行效率要求不高，因此我们选择了易于理解与上手的Python语言。从效果来看，我们的代码量相比之下变得简洁许多。但是在做UI时，我们发现UI的设计变得比较麻烦，并且由于信息不足，最初只采用Tkinter库进行UI设计，它有一个致命缺陷就是无法用坐标设定各个位置，只能通过相对位置判断，因此UI代码显得非常凌乱。之后由于Tkinter库的插件不够，又多调用了Pmw库才使得界面最终成型。因此，在代码工作前，了解并学习、选择库函数是十分重要的，并且应该合适地利用库和工具，使工作量变得更清晰更有条理。
